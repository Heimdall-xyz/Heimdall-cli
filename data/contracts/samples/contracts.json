[
  {
    "id": "simple-token",
    "name": "SimpleToken",
    "description": "A basic ERC20-like token implementation",
    "has_vulnerabilities": false,
    "contract_code": "\n            // SPDX-License-Identifier: MIT\n            pragma solidity ^0.8.0;\n            \n            contract SimpleToken {\n                string public name = \"SimpleToken\";\n                string public symbol = \"SIM\";\n                uint8 public decimals = 18;\n                uint256 public totalSupply = 1000000 * 10**18;\n                \n                mapping(address => uint256) public balanceOf;\n                mapping(address => mapping(address => uint256)) public allowance;\n                \n                event Transfer(address indexed from, address indexed to, uint256 value);\n                event Approval(address indexed owner, address indexed spender, uint256 value);\n                \n                constructor() {\n                    balanceOf[msg.sender] = totalSupply;\n                }\n                \n                function transfer(address to, uint256 value) public returns (bool) {\n                    require(to != address(0), \"Transfer to zero address\");\n                    require(balanceOf[msg.sender] >= value, \"Insufficient balance\");\n                    \n                    balanceOf[msg.sender] -= value;\n                    balanceOf[to] += value;\n                    emit Transfer(msg.sender, to, value);\n                    return true;\n                }\n                \n                function approve(address spender, uint256 value) public returns (bool) {\n                    allowance[msg.sender][spender] = value;\n                    emit Approval(msg.sender, spender, value);\n                    return true;\n                }\n                \n                function transferFrom(address from, address to, uint256 value) public returns (bool) {\n                    require(to != address(0), \"Transfer to zero address\");\n                    require(balanceOf[from] >= value, \"Insufficient balance\");\n                    require(allowance[from][msg.sender] >= value, \"Insufficient allowance\");\n                    \n                    balanceOf[from] -= value;\n                    balanceOf[to] += value;\n                    allowance[from][msg.sender] -= value;\n                    emit Transfer(from, to, value);\n                    return true;\n                }\n            }\n        "
  },
  {
    "id": "vulnerable-vault",
    "name": "VulnerableVault",
    "description": "A vault contract with a reentrancy vulnerability",
    "has_vulnerabilities": true,
    "vulnerability_types": [
      "reentrancy"
    ],
    "contract_code": "\n            // SPDX-License-Identifier: MIT\n            pragma solidity ^0.8.0;\n            \n            contract VulnerableVault {\n                mapping(address => uint256) public balances;\n                \n                function deposit() public payable {\n                    balances[msg.sender] += msg.value;\n                }\n                \n                // This function is vulnerable to reentrancy\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    \n                    // Vulnerable: sends ETH before updating the balance\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                    \n                    // State update happens after external call\n                    balances[msg.sender] -= amount;\n                }\n                \n                function getBalance() public view returns (uint256) {\n                    return balances[msg.sender];\n                }\n            }\n        "
  },
  {
    "id": "insecure-marketplace",
    "name": "InsecureMarketplace",
    "description": "A marketplace contract with access control issues",
    "has_vulnerabilities": true,
    "vulnerability_types": [
      "access-control"
    ],
    "contract_code": "\n            // SPDX-License-Identifier: MIT\n            pragma solidity ^0.8.0;\n            \n            contract InsecureMarketplace {\n                address public owner;\n                mapping(uint256 => Item) public items;\n                uint256 public itemCount;\n                \n                struct Item {\n                    string name;\n                    uint256 price;\n                    address seller;\n                    bool sold;\n                }\n                \n                constructor() {\n                    owner = msg.sender;\n                }\n                \n                function addItem(string memory _name, uint256 _price) public {\n                    itemCount++;\n                    items[itemCount] = Item(_name, _price, msg.sender, false);\n                }\n                \n                // Vulnerable: Missing access control\n                function updatePrice(uint256 _itemId, uint256 _newPrice) public {\n                    // Should check if msg.sender is the seller but doesn't\n                    items[_itemId].price = _newPrice;\n                }\n                \n                function purchaseItem(uint256 _itemId) public payable {\n                    Item storage item = items[_itemId];\n                    require(!item.sold, \"Item already sold\");\n                    require(msg.value >= item.price, \"Insufficient funds\");\n                    \n                    item.sold = true;\n                    payable(item.seller).transfer(msg.value);\n                }\n                \n                // Vulnerable: Missing access control\n                function withdrawFunds() public {\n                    // Should check if msg.sender is the owner but doesn't\n                    payable(msg.sender).transfer(address(this).balance);\n                }\n            }\n        "
  },
  {
    "id": "price-oracle",
    "name": "VulnerablePriceOracle",
    "description": "A price oracle vulnerable to flash loan attacks",
    "has_vulnerabilities": true,
    "vulnerability_types": [
      "flash-loan-attack"
    ],
    "contract_code": "\n            // SPDX-License-Identifier: MIT\n            pragma solidity ^0.8.0;\n            \n            interface IERC20 {\n                function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n                function transfer(address recipient, uint256 amount) external returns (bool);\n                function balanceOf(address account) external view returns (uint256);\n            }\n            \n            contract VulnerablePriceOracle {\n                IERC20 public token;\n                IERC20 public stablecoin;\n                \n                constructor(address _token, address _stablecoin) {\n                    token = IERC20(_token);\n                    stablecoin = IERC20(_stablecoin);\n                }\n                \n                // Vulnerable to flash loan price manipulation\n                function getPrice() public view returns (uint256) {\n                    // Simplified price calculation based on pool balances\n                    // Vulnerable to manipulation via flash loans\n                    return (stablecoin.balanceOf(address(this)) * 1e18) / token.balanceOf(address(this));\n                }\n                \n                function swap(uint256 tokenAmount) public {\n                    // Get current price\n                    uint256 price = getPrice();\n                    uint256 stablecoinAmount = (tokenAmount * price) / 1e18;\n                    \n                    // Transfer tokens from user to contract\n                    require(token.transferFrom(msg.sender, address(this), tokenAmount), \"Token transfer failed\");\n                    \n                    // Transfer stablecoins to user\n                    require(stablecoin.transfer(msg.sender, stablecoinAmount), \"Stablecoin transfer failed\");\n                }\n            }\n        "
  },
  {
    "id": "secure-vault",
    "name": "SecureVault",
    "description": "A secure vault contract with reentrancy protection",
    "has_vulnerabilities": false,
    "contract_code": "\n            // SPDX-License-Identifier: MIT\n            pragma solidity ^0.8.0;\n            \n            contract SecureVault {\n                mapping(address => uint256) public balances;\n                bool private locked;\n                \n                modifier nonReentrant() {\n                    require(!locked, \"Reentrant call\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n                \n                function deposit() public payable {\n                    balances[msg.sender] += msg.value;\n                }\n                \n                // Secure version with reentrancy protection\n                function withdraw(uint256 amount) public nonReentrant {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    \n                    // Update state before external call\n                    balances[msg.sender] -= amount;\n                    \n                    // External call after state update\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n                \n                function getBalance() public view returns (uint256) {\n                    return balances[msg.sender];\n                }\n            }\n        "
  }
]