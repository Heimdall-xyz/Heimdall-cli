"""
Create a dataset of historical blockchain exploits based on publicly available information.
"""
import json
import os
from pathlib import Path

DATA_DIR = Path(__file__).parent.parent.parent / "data" / "vulnerabilities"
EXPLOITS_DIR = DATA_DIR / "exploits"

# This dataset contains information about major DeFi hacks and exploits
# Data is collected from public post-mortems and reports
EXPLOIT_DATA = [
    {
        "id": "nomad-bridge-hack",
        "name": "Nomad Bridge Hack",
        "date": "2022-08-01",
        "amount_lost": "$190 million",
        "vulnerability_type": "Input Validation",
        "description": "The Nomad bridge was exploited due to a configuration error during a routine upgrade. The team initialized the trusted root to be 0x00, which had the effect of auto-proving every message. This allowed users to forge arbitrary messages and drain funds from the bridge.",
        "root_cause": "A configuration change made during the implementation of the Replica contract upgrade allowed the zero hash to be treated as a valid root. This meant that any arbitrary message could be proven valid.",
        "lessons": "Proper validation of protocol parameters is essential, especially during upgrades. Configuration changes should undergo the same rigorous testing as code changes.",
        "references": ["https://medium.com/nomad-xyz-blog/nomad-bridge-hack-root-cause-analysis-875ad2e5aacd"]
    },
    {
        "id": "wormhole-bridge-hack",
        "name": "Wormhole Bridge Exploit",
        "date": "2022-02-02",
        "amount_lost": "$320 million",
        "vulnerability_type": "Signature Verification Bypass",
        "description": "An attacker exploited a vulnerability in the Wormhole bridge's signature verification system, allowing them to forge valid signatures and mint tokens without actually locking them on the origin chain.",
        "root_cause": "The signature verification function was modified during an upgrade, but one call path failed to properly validate signatures, allowing the attacker to extract 120k wETH.",
        "lessons": "Complete verification of signatures is critical in cross-chain bridges. All code paths must be thoroughly tested, especially after upgrades or changes to security-critical functions.",
        "references": ["https://blog.chainalysis.com/reports/wormhole-hack-february-2022/"]
    },
    {
        "id": "ronin-bridge-hack",
        "name": "Ronin Bridge Hack",
        "date": "2022-03-23",
        "amount_lost": "$620 million",
        "vulnerability_type": "Validator Compromise",
        "description": "The Ronin bridge was compromised when an attacker gained access to private keys used to validate transactions, allowing them to authorize fraudulent withdrawals.",
        "root_cause": "The attacker gained control of 5 of the 9 validator nodes, primarily through social engineering. This gave them enough control to authorize withdrawals. The security breach went undetected for six days.",
        "lessons": "Validator key management is critical in bridge security. Systems should implement proper monitoring for unusual withdrawals and maintain a diversified validator set with robust security practices.",
        "references": ["https://roninblockchain.substack.com/p/community-alert-ronin-validators"]
    },
    {
        "id": "poly-network-hack",
        "name": "Poly Network Hack",
        "date": "2021-08-10",
        "amount_lost": "$610 million",
        "vulnerability_type": "Access Control Vulnerability",
        "description": "An attacker exploited a vulnerability in the Poly Network's cross-chain protocol that allowed them to modify the keeper role and execute unauthorized transactions.",
        "root_cause": "The vulnerability was in the EthCrossChainManager contract that allowed the attacker to call functions they shouldn't have been able to access, including the ability to transfer assets to an address of their choosing.",
        "lessons": "Proper access control mechanisms are essential in smart contracts. Critical functions should implement rigorous permission checks and enforce proper separation of privileges.",
        "references": ["https://medium.com/poly-network/poly-network-hack-full-analysis-853ad42bb178"]
    },
    {
        "id": "cream-finance-hack",
        "name": "Cream Finance Flash Loan Attack",
        "date": "2021-10-27",
        "amount_lost": "$130 million",
        "vulnerability_type": "Flash Loan Price Manipulation",
        "description": "Cream Finance was exploited through a complex flash loan attack that manipulated asset prices and drained funds from the protocol.",
        "root_cause": "The attacker used a flash loan to manipulate the price of yUSD on Curve, then used this distorted price to borrow more assets than they should have been able to from Cream Finance.",
        "lessons": "DeFi protocols should implement circuit breakers, time-weighted average prices, and multiple price oracles to protect against flash loan price manipulation attacks.",
        "references": ["https://medium.com/cream-finance/post-mortem-exploit-oct-27-507b12bb6f8e"]
    }
]

def create_exploit_dataset():
    """Create and save historical exploit dataset"""
    os.makedirs(EXPLOITS_DIR, exist_ok=True)
    
    with open(EXPLOITS_DIR / "exploits.json", "w") as f:
        json.dump(EXPLOIT_DATA, f, indent=2)
    
    # Create individual files for each exploit
    for exploit in EXPLOIT_DATA:
        exploit_dir = EXPLOITS_DIR / exploit["id"]
        os.makedirs(exploit_dir, exist_ok=True)
        
        # Save metadata
        with open(exploit_dir / "metadata.json", "w") as f:
            json.dump(exploit, f, indent=2)
        
        # Create a markdown file with detailed analysis
        with open(exploit_dir / "analysis.md", "w") as f:
            f.write(f"# {exploit['name']}\n\n")
            f.write(f"**Date:** {exploit['date']}\n")
            f.write(f"**Amount Lost:** {exploit['amount_lost']}\n")
            f.write(f"**Type:** {exploit['vulnerability_type']}\n\n")
            f.write(f"## Description\n\n{exploit['description']}\n\n")
            f.write(f"## Root Cause\n\n{exploit['root_cause']}\n\n")
            f.write(f"## Lessons Learned\n\n{exploit['lessons']}\n\n")
            f.write("## References\n\n")
            for ref in exploit["references"]:
                f.write(f"- {ref}\n")
    
    print(f"Created exploit dataset with {len(EXPLOIT_DATA)} historical exploits")

if __name__ == "__main__":
    create_exploit_dataset()