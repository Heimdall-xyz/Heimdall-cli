"""
Create a manually curated dataset of smart contract vulnerabilities.
"""
import json
import os
from pathlib import Path

DATA_DIR = Path(__file__).parent.parent.parent / "data" / "vulnerabilities"
MANUAL_DIR = DATA_DIR / "manual"

# This manual dataset focuses on well-documented vulnerability types
# using original descriptions and examples
VULNERABILITY_DATA = [
    {
        "id": "reentrancy",
        "name": "Reentrancy",
        "category": "Control Flow",
        "severity": "High",
        "description": "Occurs when external contract calls are allowed to make new calls back to the calling contract before the first execution is complete, potentially leading to multiple withdrawals or other unexpected logic flows.",
        "example_code": """
            // Vulnerable code
            function withdraw(uint256 amount) public {
                require(balances[msg.sender] >= amount, "Insufficient balance");
                
                // Send funds before updating state
                (bool success, ) = msg.sender.call{value: amount}("");
                require(success, "Transfer failed");
                
                // State update happens after external call
                balances[msg.sender] -= amount;
            }
            
            // Fixed code
            function withdraw(uint256 amount) public {
                require(balances[msg.sender] >= amount, "Insufficient balance");
                
                // Update state before external call
                balances[msg.sender] -= amount;
                
                // Send funds after updating state
                (bool success, ) = msg.sender.call{value: amount}("");
                require(success, "Transfer failed");
            }
        """,
        "detection_pattern": "External calls such as call(), send(), or transfer() occurring before state changes",
        "references": ["https://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/"]
    },
    {
        "id": "access-control",
        "name": "Missing Access Control",
        "category": "Authorization",
        "severity": "Critical",
        "description": "Critical functions lack proper authorization checks, allowing unauthorized users to execute privileged operations.",
        "example_code": """
            // Vulnerable code
            function withdrawFunds() public {
                // No access control
                payable(msg.sender).transfer(address(this).balance);
            }
            
            // Fixed code
            function withdrawFunds() public {
                // Check that caller is the owner
                require(msg.sender == owner, "Not authorized");
                payable(msg.sender).transfer(address(this).balance);
            }
        """,
        "detection_pattern": "Functions that modify critical state or transfer value without authorization checks",
        "references": ["https://consensys.github.io/smart-contract-best-practices/development-recommendations/access-control/"]
    },
    {
        "id": "arithmetic",
        "name": "Arithmetic Issues",
        "category": "Data Validation",
        "severity": "High",
        "description": "Integer overflow, underflow, or precision loss in arithmetic operations leading to unexpected behavior or asset loss.",
        "example_code": """
            // Vulnerable code (pre-Solidity 0.8.0)
            function transfer(address to, uint256 amount) public {
                require(balances[msg.sender] >= amount, "Insufficient balance");
                balances[msg.sender] -= amount;
                balances[to] += amount; // Potential overflow
            }
            
            // Fixed code for pre-0.8.0
            function transfer(address to, uint256 amount) public {
                require(balances[msg.sender] >= amount, "Insufficient balance");
                balances[msg.sender] -= amount;
                require(balances[to] + amount >= balances[to], "Overflow check");
                balances[to] += amount;
            }
        """,
        "detection_pattern": "Arithmetic operations without overflow/underflow checks in versions before Solidity 0.8.0",
        "references": ["https://consensys.github.io/smart-contract-best-practices/development-recommendations/general/integer-overflow-underflow/"]
    },
    {
        "id": "flash-loan-attack",
        "name": "Flash Loan Attack Vulnerability",
        "category": "DeFi",
        "severity": "Critical",
        "description": "Price manipulation using flash loans to exploit pricing mechanisms or oracle data, particularly in DeFi protocols.",
        "example_code": """
            // Vulnerable code
            function swap(address token, uint256 amount) public {
                // Using a single price source without time-weighted checks
                uint price = singleSourceOracle.getPrice(token);
                uint returnAmount = amount * price / 1e18;
                
                // Vulnerable to flash loan price manipulation
                token.transferFrom(msg.sender, address(this), amount);
                stablecoin.transfer(msg.sender, returnAmount);
            }
            
            // More resilient code
            function swap(address token, uint256 amount) public {
                // Using time-weighted average price from multiple sources
                uint price = twapOracle.getAveragePrice(token);
                uint returnAmount = amount * price / 1e18;
                
                // Add slippage protection
                require(returnAmount <= maxSwapAmount, "Exceeds max swap");
                
                token.transferFrom(msg.sender, address(this), amount);
                stablecoin.transfer(msg.sender, returnAmount);
            }
        """,
        "detection_pattern": "Single-block price oracle usage without manipulation protection",
        "references": ["https://chain.link/education-hub/flash-loans"]
    },
    {
        "id": "front-running",
        "name": "Front-Running Vulnerability",
        "category": "Transaction Ordering",
        "severity": "Medium",
        "description": "Lack of protection against transaction order manipulation, allowing attackers to benefit from advance knowledge of pending transactions.",
        "example_code": """
            // Vulnerable code
            function buyTokens() public payable {
                // Price is determined at execution time
                uint256 price = getCurrentPrice();
                uint256 tokenAmount = msg.value / price;
                
                // Vulnerable to front-running
                balances[msg.sender] += tokenAmount;
            }
            
            // More resistant code
            function buyTokens(uint256 maxPrice) public payable {
                uint256 price = getCurrentPrice();
                // Buyer specifies maximum price they're willing to pay
                require(price <= maxPrice, "Price too high");
                uint256 tokenAmount = msg.value / price;
                balances[msg.sender] += tokenAmount;
            }
        """,
        "detection_pattern": "Price-sensitive operations without slippage protection or commit-reveal patterns",
        "references": ["https://consensys.github.io/smart-contract-best-practices/attacks/front-running/"]
    }
]

def create_manual_dataset():
    """Create and save manual vulnerability dataset"""
    os.makedirs(MANUAL_DIR, exist_ok=True)
    
    with open(MANUAL_DIR / "vulnerabilities.json", "w") as f:
        json.dump(VULNERABILITY_DATA, f, indent=2)
    
    # Create individual files for each vulnerability
    for vuln in VULNERABILITY_DATA:
        vuln_dir = MANUAL_DIR / vuln["id"]
        os.makedirs(vuln_dir, exist_ok=True)
        
        # Save metadata
        with open(vuln_dir / "metadata.json", "w") as f:
            json.dump(vuln, f, indent=2)
        
        # Save example code
        with open(vuln_dir / "example.sol", "w") as f:
            f.write(vuln["example_code"])
    
    print(f"Created manual dataset with {len(VULNERABILITY_DATA)} vulnerabilities")

if __name__ == "__main__":
    create_manual_dataset()